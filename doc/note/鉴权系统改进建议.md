# 鉴权系统改进建议

## 当前系统分析

### 现有实现
- **JWT认证**：使用JWT token进行用户认证
- **拦截器鉴权**：在用户服务中使用`AuthInterceptor`进行鉴权
- **Token解析**：使用`TokenParseInterceptor`解析token（可选）
- **密码加密**：使用MD5加密
- **登录限制**：实现了登录失败锁定机制

---

## 发现的安全问题

### 🔴 严重问题

#### 1. **JWT密钥硬编码**
**位置**：`novel-core/novel-common/src/main/java/com/novel/common/auth/JwtUtils.java:26`

```java
private static final String SECRET = "E66559580A1ADF48CDD928516062F12E";
```

**风险**：
- 密钥泄露风险高
- 无法在不同环境使用不同密钥
- 代码泄露即密钥泄露

**建议**：
- 将密钥配置到配置文件（Nacos/配置文件）
- 使用环境变量
- 生产环境使用密钥管理服务（如阿里云KMS）

---

#### 2. **JWT没有过期时间**
**位置**：`JwtUtils.generateToken()`方法

**问题**：
- Token永久有效，一旦泄露无法自动失效
- 无法强制用户重新登录
- 安全风险极高

**建议**：
- 添加`expiration`时间（如7天）
- 实现Refresh Token机制（30天有效期）
- 支持Token刷新接口

---

#### 3. **密码加密不安全**
**位置**：`UserServiceImpl.java:95-96, 138-139`

```java
DigestUtils.md5DigestAsHex(dto.getPassword().getBytes(StandardCharsets.UTF_8))
```

**问题**：
- MD5算法已被破解，不安全
- Salt固定为"0"，没有实际作用
- 容易被彩虹表攻击

**建议**：
- 使用BCrypt或Argon2算法
- 每个用户使用随机Salt
- 增加密码复杂度要求

---

#### 4. **没有Token黑名单机制**
**问题**：
- 用户登出后Token仍然有效
- 无法主动使Token失效
- 无法处理Token泄露场景

**建议**：
- 实现Token黑名单（Redis存储）
- 登出时将Token加入黑名单
- 验证Token时检查黑名单

---

### 🟡 中等问题

#### 5. **网关层缺少统一鉴权**
**现状**：
- 鉴权分散在各个服务中
- 网关只做路由转发
- 每个服务都要实现鉴权逻辑

**建议**：
- 在网关层实现统一鉴权过滤器
- 验证通过后转发请求
- 减少后端服务鉴权压力

---

#### 6. **TokenParseInterceptor可能设置null值**
**位置**：`TokenParseInterceptor.java:28`

```java
UserHolder.setUserId(JwtUtils.parseToken(token, SystemConfigConsts.NOVEL_FRONT_KEY));
```

**问题**：
- 如果token解析失败，会设置null到UserHolder
- 可能导致后续逻辑异常

**建议**：
- 解析失败时不设置，或明确处理null情况

---

#### 7. **没有Token刷新机制**
**问题**：
- 用户需要重新登录才能获取新Token
- 用户体验差
- 无法实现"记住我"功能

**建议**：
- 实现Access Token（短期，如7天）+ Refresh Token（长期，如30天）
- 提供Token刷新接口
- 刷新时验证Refresh Token有效性

---

#### 8. **缺少防止重放攻击机制**
**问题**：
- 没有nonce或时间戳验证
- 可能被重放攻击

**建议**：
- 在JWT中添加`iat`（签发时间）和`jti`（JWT ID）
- 使用Redis存储已使用的nonce
- 验证请求时间戳

---

### 🟢 优化建议

#### 9. **Token验证性能优化**
**建议**：
- 缓存Token验证结果（短期缓存，如5分钟）
- 减少重复的JWT解析和用户信息查询

---

#### 10. **用户状态检查**
**位置**：`AuthInterceptor.java:55-60`

**建议**：
- 检查用户状态（是否被禁用）
- 检查用户是否被锁定
- 在Token验证时一并检查

---

#### 11. **日志和监控**
**建议**：
- 记录鉴权失败日志（包含IP、User-Agent等）
- 监控异常登录行为
- 告警机制

---

## 改进方案

### 方案一：快速改进（推荐优先实施）

1. **JWT添加过期时间**
   - 修改`JwtUtils.generateToken()`添加过期时间
   - 默认7天过期

2. **JWT密钥外部化**
   - 将密钥移到配置文件
   - 使用`@Value`或`@ConfigurationProperties`注入

3. **实现Token黑名单**
   - 使用Redis存储黑名单
   - 登出接口添加Token到黑名单
   - 验证时检查黑名单

4. **密码加密升级**
   - 替换MD5为BCrypt
   - 使用随机Salt

### 方案二：完整改进（长期规划）

1. **网关统一鉴权**
   - 实现`AuthGlobalFilter`
   - 在网关层验证Token
   - 验证通过后转发请求

2. **Refresh Token机制**
   - 实现双Token机制
   - Access Token（短期）
   - Refresh Token（长期，存储到Redis）

3. **安全增强**
   - 添加防重放攻击机制
   - 实现Token刷新频率限制
   - 添加设备管理（多设备登录控制）

---

## 实施优先级

### P0（立即修复）
1. ✅ JWT添加过期时间
2. ✅ JWT密钥外部化
3. ✅ 密码加密升级

### P1（近期实施）
4. ✅ Token黑名单机制
5. ✅ 网关统一鉴权
6. ✅ 用户状态检查

### P2（长期优化）
7. ✅ Refresh Token机制
8. ✅ 防重放攻击
9. ✅ 日志和监控增强

---

## 参考实现

### JWT过期时间示例
```java
public static String generateToken(Long uid, String systemKey, long expirationMs) {
    return Jwts.builder()
            .header()
            .add(HEADER_SYSTEM_KEY, systemKey)
            .and()
            .subject(uid.toString())
            .issuedAt(new Date())
            .expiration(new Date(System.currentTimeMillis() + expirationMs))
            .signWith(Keys.hmacShaKeyFor(SECRET.getBytes(StandardCharsets.UTF_8)))
            .compact();
}
```

### Token黑名单检查示例
```java
// 验证Token时
if (tokenBlacklistService.isBlacklisted(token)) {
    throw new BusinessException(ErrorCodeEnum.USER_LOGIN_EXPIRED);
}
```

### BCrypt密码加密示例
```java
String hashedPassword = BCrypt.hashpw(password, BCrypt.gensalt());
boolean matches = BCrypt.checkpw(password, hashedPassword);
```

---

## 总结

当前鉴权系统存在多个安全隐患，建议优先修复P0级别的问题。特别是JWT没有过期时间和密钥硬编码，这两个问题需要立即修复。

改进后，系统安全性将显著提升，同时用户体验也会得到改善（如Token刷新机制）。
