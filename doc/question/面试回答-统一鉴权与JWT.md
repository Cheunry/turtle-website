# 面试回答：统一鉴权与JWT

## 面试回答

关于统一鉴权，我们项目选择了JWT方案而不是OAuth2。主要原因是JWT的无状态特性非常适合微服务场景，避免了服务间session共享的问题。而且JWT是自包含的，服务端验证token时不需要查数据库或缓存，性能更好。OAuth2更适合第三方授权场景，比如微信登录、QQ登录，我们当前是自建用户体系，不需要那么复杂的授权流程。

在架构设计上，我们采用了网关层加服务层的分层鉴权策略。网关层用Spring Cloud Gateway做路由转发，目前没有做统一鉴权拦截，但可以扩展。服务层通过拦截器实现鉴权，我们设计了两套拦截器：一套是严格鉴权，用于用户服务和作者中心，必须携带有效token；另一套是可选鉴权，用于其他服务，有token就解析用户信息，没有token也放行，这样可以根据不同业务场景灵活处理。

具体的鉴权流程是这样的：用户登录或注册时，用户服务验证身份后，用JwtUtils生成JWT，包含用户ID和系统标识。前端在HTTP Header的Authorization字段中携带token。请求到达服务端后，拦截器调用JwtUtils解析token，验证签名和系统标识。解析成功后，从Redis缓存获取用户信息，存入UserHolder，这是用ThreadLocal实现的，可以在整个请求生命周期内传递用户信息，避免参数传递。请求结束后，在拦截器的afterCompletion方法中清理ThreadLocal，防止内存泄漏。

在安全机制方面，我们在JWT的Header中加入了系统标识，用来区分前台、作者、后台等不同系统，防止token跨系统使用。使用HMAC-SHA256算法对token签名，确保不被篡改。用户信息优先从Redis缓存获取，减少数据库查询。还实现了登录失败锁定机制，连续5次失败就锁定30分钟，防止暴力破解。

关于token刷新机制，目前项目还没有实现，每次登录生成新token，token也没有过期时间。这确实是一个需要改进的地方，因为我们是公开的小说网站，面向C端用户，安全性要求更高。如果token泄露，没有过期时间就意味着永久有效，风险很大。我计划采用双token方案来解决这个问题：Access Token短期有效，比如2小时，用于业务请求；Refresh Token长期有效，比如7天，存在Redis里，用来刷新Access Token。登录时同时生成两个token，前端检测到Access Token过期就调用刷新接口，服务端验证Refresh Token后生成新的Access Token。还可以在网关层做统一刷新，检测到token快过期就自动刷新，对前端透明。为了安全，可以加入单点登录机制，同一用户只保留一个有效Refresh Token，登出时把token加入Redis黑名单，Refresh Token使用后生成新的，定期轮换。另外，还需要给JWT加上过期时间，即使没有刷新机制，也能在一定时间后自动失效。

这个方案的技术亮点主要是用ThreadLocal传递用户信息，避免参数传递，代码更简洁；用户信息优先从缓存获取，减少数据库压力；通过系统标识实现系统隔离，提升安全性；拦截器设计支持不同服务的不同鉴权策略，可扩展性强。

未来优化方向包括：把密钥从硬编码改为从Nacos配置中心读取；考虑升级到RSA非对称加密；加入时间戳和随机数防重放攻击；把鉴权逻辑上移到网关层，减少各服务重复代码；最后就是实现刚才说的token刷新机制。

总的来说，我们采用JWT实现统一鉴权，通过拦截器在服务层完成验证，利用ThreadLocal传递用户信息。虽然目前还没实现token刷新，但架构设计支持后续扩展。这个方案在保证安全性的同时，兼顾了性能和开发效率。
