# 服务间通信方式 - 面试回答

## 问题：服务间通信用的是什么？REST、gRPC 还是消息队列？为什么？

---

## 回答

我们项目主要用了两种方式：**同步用 OpenFeign（基于 REST）**，**异步用 RocketMQ**。目前没有用 gRPC。

### 先说同步通信这块

同步场景主要用 **OpenFeign**，因为大部分是查询类操作，需要立即返回结果。比如批量查用户信息、查书籍详情、AI 服务的一些同步调用，这些场景用 Feign 比较合适。

我们做了几个优化：
- 所有 Feign 接口都配了 **fallback 降级**，比如 AI 审核服务挂了，会返回失败响应而不是拖垮整个链路
- 通过 Nacos 做服务发现，配合 Spring Cloud LoadBalancer 做负载均衡
- 内部 API 统一用 `API_INNER_*` 前缀，和对外接口隔离

### 异步通信这块是重点

**RocketMQ** 主要用在需要解耦、削峰、最终一致性的场景。

**第一个典型场景是书籍审核流程**。作者提交书籍或章节后，book 服务把审核请求发到 MQ，AI 服务消费后做内容审核，审核结果再通过另一个 MQ topic 回传给 book 服务，book 服务收到后更新数据库、发通知给用户。这样 AI 服务就算慢一点或者临时不可用，也不会阻塞作者提交，用户体验更好。

**第二个是搜索索引同步**。书籍信息变更后，我们发 MQ 通知 search 服务，它消费后更新 ES，还会调用 DashScope 生成向量做语义搜索。这个链路完全异步，即使 ES 更新失败，MQ 也会重试，保证最终一致性。

**第三个是作者积分消费**。积分扣减先写 Redis，然后发 MQ 异步落库。这样高并发场景下不会因为数据库写入慢影响用户体验，而且通过幂等键保证不会重复扣减。

**第四个是书籍章节提交的完全异步化**。作者提交章节时，我们只做轻量级校验，然后立即发 MQ 返回，真正的数据库操作、审核流程都在消费者里异步处理。这样网关线程能快速释放，吞吐量提升很明显。

### 为什么不用 gRPC

主要考虑几个点：
- 我们服务都是 Java，同构环境下 HTTP/JSON 够用了，开发调试都方便
- 网关、鉴权、监控（SkyWalking）这些基础设施对 HTTP 支持更好
- 目前业务对延迟要求没那么极致，REST 的延迟已经能满足

如果以后有跨语言调用或者对延迟要求特别高的场景，再考虑 gRPC。

### 总结

整体思路是：**同步场景用 Feign，异步解耦用 MQ**。这样既保证了实时性，又通过异步化提升了系统吞吐和容错能力。实际运行下来，这套方案比较稳定，MQ 的重试机制和幂等设计也帮我们解决了很多一致性问题。

---

## 可能的追问点

### 1. Feign 超时和重试怎么配置的？
我们通过 Spring Cloud 的配置中心（Nacos）统一管理超时时间，一般读操作 3 秒，写操作 5 秒。重试策略是默认的，失败会重试一次。降级通过 fallback 实现，服务不可用时返回默认值或失败响应。

### 2. MQ 消息重复消费怎么处理？
我们通过业务幂等键来保证。比如审核请求会生成唯一的 taskId，审核结果消费时会用这个 taskId 去重。积分消费日志表有唯一索引，通过 idempotentKey 防止重复插入。这样即使 MQ 重复投递，业务层也能保证幂等。

### 3. MQ 消费失败怎么办？
RocketMQ 有重试机制，默认会重试 16 次，时间间隔递增。如果重试都失败，消息会进入死信队列，我们会有定时任务扫描死信队列做补偿。关键业务还会记录失败日志，方便人工介入。

### 4. 最终一致性怎么保证的？
写操作先落库，然后发 MQ 通知其他服务。比如书籍更新后，会发 MQ 通知 ES 同步。如果 ES 更新失败，MQ 会重试，直到成功。读操作优先读缓存，缓存失效后再读数据库。这样既保证了性能，又保证了最终一致性。

### 5. 大流量下怎么保护系统？
入口网关用 Sentinel 做限流，防止突发流量打垮服务。写操作尽量异步化，比如章节提交、审核流程都走 MQ，减少长事务。热点数据先写 Redis，失败再降级到 MQ 补偿。这样即使数据库压力大，也能保证核心功能可用。
