# 分布式事务一致性 - 面试回答

## 问题：如何保证分布式事务一致性？是否使用 Seata 或其他方案？

---

## 回答

我们项目**没有使用 Seata**，而是采用了**基于消息队列的最终一致性方案**。主要考虑是业务场景对强一致性要求不高，更看重性能和可用性。

### 整体思路

我们采用**本地事务 + MQ 异步 + 幂等性保证**的组合方案。每个服务内部用 `@Transactional` 保证单服务内的 ACID，跨服务操作通过 RocketMQ 异步处理，通过幂等键和补偿机制保证最终一致性。

### 具体实现

**第一个是书籍审核流程**。作者提交书籍后，book 服务先落库，然后发 MQ 通知 AI 服务审核。AI 服务审核完成后，再发另一个 MQ 回传结果，book 服务收到后更新数据库、发通知。这个流程里，每个服务内部都是本地事务，跨服务通过 MQ 解耦。如果 AI 服务挂了，MQ 会重试，不会影响作者提交。

**第二个是作者积分消费**。这是比较典型的场景。积分扣减先写 Redis（原子操作），然后发 MQ 异步落库。这样高并发下不会因为数据库写入慢影响用户体验。关键是我们通过 `idempotentKey` 保证幂等性：每次扣分请求生成唯一标识，Redis 用 SETNX 防重，数据库日志表也有唯一索引，即使 MQ 重复投递也不会重复扣分。如果 AI 服务调用失败，我们还有回滚机制，通过另一个 MQ topic 把积分加回去。

**第三个是书籍章节提交的完全异步化**。作者提交章节时，我们只做轻量级校验，然后立即发 MQ 返回。真正的数据库操作、审核流程都在消费者里用本地事务处理。这样网关线程能快速释放，吞吐量提升很明显。而且我们用了 `TransactionSynchronization`，确保数据库事务提交后再发 MQ，避免事务还没提交就发消息导致的数据不一致。

**第四个是搜索索引同步**。书籍信息变更后，我们发 MQ 通知 search 服务更新 ES。如果 ES 更新失败，MQ 会重试，直到成功。这样保证了数据库和 ES 的最终一致性。

### 幂等性保证

这是关键。我们主要通过几个方式：
- **业务幂等键**：审核请求生成唯一的 `taskId`，审核结果消费时用这个 `taskId` 去重
- **数据库唯一索引**：积分消费日志表有 `idempotentKey` 的唯一索引，防止重复插入
- **Redis SETNX**：积分扣减时用 SETNX 做前置检查，24 小时过期
- **业务去重**：章节提交时校验章节号是否重复，书籍提交时校验书名是否重复

### 补偿机制

如果某个环节失败了，我们有几种补偿方式：
- **MQ 重试**：RocketMQ 默认重试 16 次，时间间隔递增
- **业务回滚**：比如积分扣减后 AI 服务调用失败，会发回滚 MQ 把积分加回去
- **定时任务补偿**：关键业务会记录失败日志，后续可以通过定时任务扫描补偿
- **死信队列**：如果重试都失败，消息会进入死信队列，方便人工介入

### 为什么不用 Seata

主要考虑几个点：
- **性能**：Seata 的 AT 模式需要全局锁，对性能有影响。我们业务对强一致性要求不高，最终一致性就够了
- **复杂度**：Seata 需要额外的 TC 服务器，增加了运维成本。我们通过 MQ + 幂等性已经能满足需求
- **业务特点**：我们很多操作都是异步的，比如审核、索引同步，天然适合最终一致性
- **可用性**：如果某个服务挂了，Seata 的全局事务会回滚，可能影响其他服务。我们用 MQ 解耦，一个服务挂了不影响其他服务

### 总结

整体来说，我们通过**本地事务保证单服务一致性，MQ 保证跨服务最终一致性，幂等性保证不重复处理，补偿机制保证失败可恢复**。实际运行下来，这套方案比较稳定，既保证了数据一致性，又保证了系统性能和可用性。

---

## 可能的追问点

### 1. 如果 MQ 消息丢失怎么办？
RocketMQ 有消息持久化机制，消息会先写磁盘再返回。如果 Broker 挂了，消息也不会丢。而且我们用的是事务消息，确保本地事务提交后才发消息。如果真的丢了，可以通过业务日志和定时任务补偿。

### 2. 如何保证 MQ 消息的顺序性？
我们通过业务设计来保证。比如审核流程，book 服务发审核请求，AI 服务处理完再发结果，通过两个不同的 topic 和 consumer group 隔离。同一个书籍的审核请求和结果通过 `taskId` 关联，不需要严格顺序。如果真的有顺序要求，可以用同一个 topic 的同一个队列，或者用业务层去重。

### 3. 如果数据库事务提交了，但 MQ 发送失败怎么办？
我们用 `TransactionSynchronization` 的 `afterCommit` 钩子，确保事务提交后再发 MQ。如果事务提交后 MQ 发送失败，会记录日志，后续可以通过定时任务补偿。关键业务还会在数据库记录状态，比如审核状态，即使 MQ 失败也能通过查询状态补偿。

### 4. 如何保证 Redis 和数据库的一致性？
我们采用**Redis 作为数据源，数据库作为持久化**的策略。积分扣减先写 Redis，然后发 MQ 异步同步到数据库。消费 MQ 时，会从 Redis 读取最新值同步到数据库，这样保证了最终一致性。如果 Redis 挂了，会降级到数据库，但这种情况很少。

### 5. 如果两个服务同时操作同一个资源怎么办？
我们通过业务锁和幂等性来保证。比如积分扣减，用 Redis SETNX 做分布式锁，防止并发重复扣减。数据库层面也有唯一索引，即使并发插入也会被拦截。审核流程通过 `taskId` 关联，同一个审核请求只会处理一次。

### 6. 最终一致性会有多久的延迟？
一般 MQ 消费延迟在几十毫秒到几百毫秒，大部分场景下用户感知不到。比如审核流程，作者提交后立即返回，审核结果通过消息通知，用户可以通过消息中心查看。搜索索引同步也是异步的，延迟在秒级，对搜索体验影响不大。
